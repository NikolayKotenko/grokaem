<?php
require_once 'init.php';

$obj = new FirstChapter();

//log 2 100(2) = 7mc
//log 2 10.000(4) = 14mc
//log 2 100.000.000(8) = 28mc
//log 2 10.000.000.000.000.000(16) = 56mc
//debug($obj->binarySearch(range(1,4000000), 39));

class FirstChapter
{
    //О-большое - кол-во операций, описывает худший возможный случай
    //simple search - O(n)
    //binary search - O(log n)
    /**
        Скорость алгоритмов измеряется не в секундах, а в темпе роста количе-
        ства операций.

        По сути формула описывает, насколько быстро возрастает время выпол-
        нения алгоритма с увеличением размера входных данных.

        Время выполнения алгоритмов выражается как «О-большое».

        Бремя выполнения O(log п) быстрее О(п), а с увеличением размера спи-
        ска, в котором ищется значение, оно становится намного быстрее.
    */

    public function FindNumberInPhoneBook()
    {
        /**
         * Приведите время выполнения О-большое для каждого из следующих сценариев
        */

        /* 1. Известна фамилия, нужно найти номер в телефонной книге. */
        /*
         *  Ответ - O(log n)
         *  O(log 2) = 2
        */

        /* 2. Известен номер, нужно найти фамилию в телефонной книге. (Под-
            сказка: вам придется провести поиск по всей книге!) */
        /*
         *  Ответ - O(n)
         *  O(2) = 2
        */
        /* 3. Нужно прочитать телефоны всех людей в телефонной книге.*/
        /*
         *  Ответ - O(n)
         *  O(2) = 2
        */
        /* 4. Нужно прочитать телефоны всех людей, фамилии которых начинают-
            ся с буквы «А». (Вопрос с подвохом! В нем задействованы концепции,
            которые более подробно рассматриваются в главе 4. Прочитайте от-
            вет - скорее всего, он вас удивит!)*/
        /*
         *  Ответ - O(log n), 33 буквы, бинарный поиск по 33 буквам, не больше 5 проходов,
         *  найдем ключи в которых хранятся все на букву А. Затем кол-во найденых (допустим 10) плюсуем к кол-ву проходов
         *  O(log n + n) = 15. TODO неправильно
        */
        $data = [
            [
                'phone' => '89995704787',
                'name' => 'Nikolay',
            ],
            [
                'phone' => '89195704787',
                'name' => 'Nikolay2',
            ],
        ];
    }
    public function binarySearch($arr, $x)
    {
        // check for empty array
        if (count($arr) === 0) return false;
        $low = 0;
        $high = count($arr);

        $count = 0;
        $res = [];

        while ($low <= $high) {

            // compute middle index
            $mid = floor(($low + $high) / 2);
            // element found at mid
            if($arr[$mid] == $x) {
                $res['found_x'] = $x;
                $res['count_iterate'] = $count;
                return $res;
            }

            /*
                Счетчик кол-ва итерации и результирующий массив после совпадения, иначе лишняя итерация
            */
            $count++;
            $res[$arr[$mid]] = [
                '$low' => $low,
                '$high' => $high,
                'mid' => $mid,
                'cur_pos' => $arr[$mid],
                'iterate' => $count,
            ];

            /*
                Условия при которых гуляем дальше
            */
            // Если текущая итерация больше икса тогда ищем в диапазоне от текущего наибольшего до минимального
            if ($arr[$mid] > $x){
                $res[$arr[$mid]]['search_direction'] = 'low';
                $high = $mid - 1;
            }
            else{
                $res[$arr[$mid]]['search_direction'] = 'high';
                $low = $mid + 1;
            }
        }
        // If we reach here element x doesnt exist
        return false;
    }
}